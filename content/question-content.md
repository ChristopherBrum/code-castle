
# Quiz Questions for Game

---

```ruby
a = 'string'
a_before_reassignment = a.______
a = 'a different string'
a_after_reassignment = a.______
a_before_reassignment == a_after_reassignment
```

Returns: `true` (last line)

Answers: `['object_id']`

Description: variable reassignment is always non-mutating, because it causes the variable to point to a _new_ object, rather than changing the one it previously referenced.

---

```ruby
def make_uppercase(string)
  string = string.______
  string
end

a = 'defeat monsters'

puts make_uppercase(a)
puts a
```

Outputs: `'DEFEAT MONSTERS'` then `'defeat monsters'`

Answers: `['upcase']`

Description: Copies of objects can be created within a method if we pass objects into methods tht contain reassignment statements. Acting on a reference that has been passed to a method as an argument with a non-mutating method does not mutate the object that was passed as an argument.

---

```ruby
def pluralize(string)
  string ______ 's'
  string
end

a = 'programmer'
b = pluralize(a)

a == b
```

Returns: `false` (last line)

Answers: `['+=', '= string +']`

Description: Assignment operators such as `+=`, `-=`, `*=`, etc can also create a copy of an object passed to a method as an argument. Because they constitute reassignment, these are also considered non- mutating. The code `a == b` returns `false` because `a` references the original string object `'programmer'` while `b` references the string object `'programmers'` which was returned by the `+` method and reassigned to `string` within `pluralize`.

---

```ruby
def emphasize(string)
  string = ______
end

a = 'code with intent'
puts emphasize(a)
puts a
```

Outputs: `'CODE WITH INTENT'` followed by `'CODE WITH INTENT'`

Answers: `['upcase']`

Description: The only time in which reassignment can mutate the original object referenced by the variable is when that same object is returned by the expression to the right of the assignment operator. Mutating methods frequently return `self` (this same object), so in this case the same object is reassigned back to `string`.

---

```ruby
# Methods can mutuate in one of two ways. Either with respect to their ______ or with respect to their ______.
```

Answers: `['arguments', 'caller']`

Description: A method that mutates with respect to its arguments is one that mutates an object that's passed to it when invoked. A method that mutates the caller is one that mutates the calling object itself. The latter is more common than the former. Mutating methods are often demarcated by `!` at the end of their name in Ruby documentation.

---

```ruby
def change_first_element(array)
  ______
  array
end

a = [1, 2, 3, 4]
change_first_element(a)
p a
```

Outputs: `[0, 2, 3, 4]`

Answer: `['array[0] = 0']`

Description: Indexed assignment, when a single element in a collection is reassigned, is mutating even though it looks like a regular assignment statement. This is because the new object created by the reassignment is only on the level of a single element _within_ the collection. The reference to the collection object as a whole remains the same.

---

```ruby
def pluralize(string)
  string << 's'
  string
end

a = 'programmer'
b = pluralize(a)

a == b
```

Returns: `true` (last line)

Answer: `['<<']`

Description: The shovel concatenation operator (`<<`) functions similarly to `+=` with string objects, _except_ that it is a mutating method whereas `+=` is not. Here `a == b` will output `true` because both `a` and `b` will point to the same object in memory.

---

```ruby
def change_object(string)
  ______
end

a = 'change me inside the method'

puts change_object(a)
puts a
```

Output: `'CHANGE ME INSIDE THE METHOD'` then `'CHANGE ME INSIDE THE METHOD'`

Answer: `['string.upcase!']`

Description: A language is said to be _pass by referece_ when a _reference_ to the actual object in memory is passed to a method when we pass methods their arguments. Access to this reference allows methods to permanently change the original objects in memory from within the method's scope. Here we are able to permanently change the original object referenced by `a` by calling a mutating method, `upcase!` on it.

---

```ruby
def change_object(string)
  ______
end

a = 'change me inside the method'

puts change_object(a)
puts a
```

Outputs: `'CHANGE ME INSIDE THE METHOD'` THEN `'change me inside the method'`

Answer: `['string.upcase']`

Description: A _pass by value_ language is one that passes a _copy_ of any given object to the method as an argument instead of a reference to the original object. In a pass by value language, we cannot mutate arguments from within the scope of a method. Ruby is not pass by value, but it can act as if it is, when a copy is generated by a method that is not mutating. Generally, non-mutating methods return some kind of newly created object, which we must capture in a variable so we can utilize them later.

---

```ruby
a = 'hey there!'
a = b
c = 'hey there!'

puts a.___(b)
puts a.___(c)
```

Outputs: `true` followed by `false`

Answer: `equal?`

Description: In Ruby, variables are containers that house references to objects in memory. These objects are assigned to variables using an assignment statement. Once assigned, variables are said to reference the assigned object. If you assign one variable to another, both of those variables will reference the same object in memory. You can use the `.equal?` method to determine if two values are, in fact, the same object in memory. `.equal?` will only return `true` if the actual objects are the same, `false` otherwise, even if the values match, as is the case when we compare `a` and `c` above.

---

```ruby
# Name one kind of immutable object in Ruby
```

Answers: `['integers', 'floats', 'true', 'false', 'nil', 'ranges']`

Description: An immutable object is one that cannot be changed. Ostensibly, this means that no mutating methods are defined for immutable objects. Note that because numerical objects in Ruby are immutable, any arithmetic operations we perform will always return a new value, and never mutate the original.

---

```ruby
a = 'how many of me are there?'
b = 'how many of me are there?'
c = 'how many of me are there?'
d = 'how many of me are there?'

match = a.object_id

same_objects_in_mem = [b, c, d].select { |obj| obj.object_id == match }

p same_objects_in_mem
# => ______
```

Outputs: ???

Answer: `[]`

Description: Just because values are equal does not necessarily mean they are the same object in memory. All four string objects initialized above are different objects in memory. Therefore, only one of them `a` will have an object id that matches that of `a`. Therefore none of the strings will be selected and an empty array will be output.

---

```ruby
colors = ['blue', 'green']
______ = colors
puts a
puts b

a = 'purple'
puts array
```

Outputs: `'blue'` followed by `'green'` followed by `['purple', 'green']`

Answer: `['a, b']`

Description: We can use parallel assignment to assign the elements in an array to different variables. The syntax is `var_1, var_2 = [ele_1, ele_2]`. Be warned, a collection as a whole can be mutated through a variable that references one of its elements. Here, when we reassign `a` and change `'blue'` to `'purple'` we mutate the array `colors`.

---

```ruby
fruits = ['apple', 'banana', 'cantaloupe', 'durian']
fruits.freeze
______
p fruits
```

Output: `['apple!!!', 'banana', 'cantaloupe', 'durian']`

Answer: `['fruits[0] << !!']`

Description: Freezing a collection only works on the higher level of the collection as a whole. Because the individual elements are distinct object references on their own, they are not frozen and can still be mutated. This results in a permanent change to the collection as a whole.

---

```ruby
colors = ['red', 'yellow']
fruits = ['apple', 'banana']
stuff = [colors, fruits]
p stuff

______
p stuff
```

Outputs: `[['red', 'yellow'], ['apple', 'banana']]` followed by `[['red', 'purple'], ['apple', 'banana']]`

Answer: `['fruits[1] = 'purple']`

Description: Nested collections have many levels of variable reference, all of which can be assigned to different variables. Changing anything on a lower level, such as the `fruits[1]` element here which is changed from `'yellow'` to `'purple'` can mutate the collection as a whole.

---

```ruby
def shout(string)
  ______
  ______
  string
end

a = 'why are we shouting'

puts shout(a)
puts a
```

Outputs: `'WHY ARE WE SHOUTING!!!'` followed by `'WHY ARE WE SHOUTING'`

Answers: `['string.upcase!', "string += '!!!'"]`

Description: The link between method argument and the original argument passed in can be broken at any point during the method execution. Here we pass in the string `'why are we shouting'` which gets mutated by the `upcase!` method. However, then we try to apply `'!!!'` with the `+=` reassignment operator, which returns a new value. Therefore, the original string never gets the `'!!!'` concatenated, as shown by the output.

---

```ruby
def redact_information(string)
  ______
end

credit_card = '1234-1234-1234-1234'

puts redact_information(credit_card)
puts credit_card
```

Outputs: `'#1234'` followed by `'#1234'`

Answers: `["string [0...string.length - 4] = '#'"]`

Description: By using all the various ways of individual element reference available to use for collections such as strings and arrays, we can mutate whole sections of these collections through element reassignment. Here we take a long string representing a credit card number and try to the sensitive information better for display. In doing so, however, we permanently modify the original string and lose important data.

---

```ruby
# Name two String methods that mutate the caller and do not contain an ! in their names.
```

Answers: `['clear', 'replace', 'insert', 'concat', 'prepend', '<<', '[]=']`

Description: While it is a convention that most mutating methods will be named with a `!`, there are some that are not. It's good to be aware of them so you don't wind up with unexpected behavior.

---

```ruby
# Name four Array methods that mutate the caller and do not contain an ! in their names.
```

Answers: `['<<', '[]=', 'append', 'clear', 'concat', 'delete', 'delete_at', 'delete_if', 'fill', 'replace', 'insert', 'keep_if', 'pop', 'prepend', 'unshift', 'push', 'shift']`

Description: While it is a convention that most mutating methods will be named with a `!`, there are some that are not. It's good to be aware of them so you don't wind up with unexpected behavior.

---

```ruby
array = ['a', 'b', 'c', 'd']

array.each do |letter|
  _____
end

p array
```

Outputs: `["A", "B", "C", "D"]`

Answers: `['letter.upcase!']`

Description: It's also possible to mutate elements within a collection while iterating over it. Be careful that you don't make any permanent changes to your collections while manipulating on the level of a single element.

---

```ruby
i = 0
______ do
  i += 2
  puts i
  break if i >= 10
end
```

Outputs: 2, 4, 6, 8, and 10 on separate lines.

Answer: `['loop']`

Description: This is an example of iteration using the `Kernal#loop` method to iterate through a collection. The blank line is missing the `loop` method invocation.

---

```ruby
i = 0
loop do
  i += 2
  puts i
  ______ if i >= 10
end
```

Outputs: 2, 4, 6, 8, and 10 on separate lines.

Answer: `['break']`

Description: This is an example of iteration using the `Kernal#loop` method to iterate through a collection. The missing element is a `break` keyword, which will exit the loop when a certain condition is met.

---

```ruby
array = ['one', 'two', 'three', 'four']
______ = 0

loop do
  puts array[counter]
  counter += 1
  break if counter >= array.length
end
```

Outputs: one, two, three, and four on separate lines.

Answer: `['counter']`

Description: This is an example of iteration using the `Kernal#loop` method to iterate through a collection. In order to break out of a loop the `break` keyword can be used. When used in conjunction with an `if` conditional statement the condition must evaluate to true in order for the `break` keyword to execute and to exit the loop. In this example the object referenced by local variable `counter` is being asked if it is greater than or equal to the the length of `array`. When this evaluates to `true` then the `break` keyword will break out of the loop. Because of variable scoping rules local variable `counter` must be initialized outside of the block passed to the `Kernal#loop` method so that it can be incremented upon each iteration of the loop. Therefore local variable `counter` should be initialized to integer object `0` on the second line.

---

```ruby
array = ['one', 'two', 'three', 'four']
counter = 0

loop do
  puts array[counter]
  ______ += 1
  break if counter >= array.length
end
```

Outputs: one, two, three, and four on separate lines.

Answer: `['counter']`

Description: This is an example of iteration using the `Kernal#loop` method to iterate through a collection. In order to break out of a loop the `break` keyword can be used. When used in conjunction with an `if` conditional statement the condition must evaluate to true in order for the `break` keyword to execute and exit the loop. In this example the object referenced by local variable `counter` is being asked if it is greater than or equal to the the length of `array`. When this evaluates to `true` then the `break` keyword will break out of the loop. In order for the `if` conditional to evaluate to `true` the object referenced by `counter` must be incremented, or else the result will be an infinite loop. Therefore, the clank line should be local variable `counter`.

---

```ruby
animals = {
  'dogs' => 12,
  'cats' => 19,
  'turtles' => 31
}

animals_to_adopt = animals.keys
counter = 0

loop do
  break if counter >= animals.length
  current_animal = animals_to_adopt[counter]
  current_animals_available = animals[current_animal]
  puts "The shelter has #{current_animals_available} #{current_animal} available to adopt."
  ______ += 1
end
```

Outputs: The shelter has 12 dogs available to adopt, The shelter has 19 cats available to adopt,  The shelter has 31 turtles available to adopt, all on separate lines.

Answer: `['counter']`

Description: This is an example of iteration using the `Kernal#loop` method to iterate through a collection. In order to break out of a loop the `break` keyword can be used. When the `break` keyword if executed based on an `if` conditional statement there needs to be an element that triggers the `if` statement to evaluate to `true`. This can be done in many ways. In this example the `break` keyword is only executed if the `if` conditional statment evaluates that the object referenced by `counter` is greater than or equal to the length of the `animals` hash. Knowing that `counter` is intialized to `0` above the `Kernal#loop` invocation, somewhere in the block passed to the `Kernal#loop` method `counter` needs to be incremented in order to avoid an infinite loop and trigger the `break` keyword execution. The blank space should be `counter` in order for this code to function properly.

---

```ruby
array = [1, 2, 3, 4, 5, 6, 7]
counter = 0
evens = []

loop do
  break if counter >= array.length
  if array[counter].even?
    ______ << array[counter]
  end
  counter += 1
end

p array
p evens
```

Outputs: [1, 2, 3, 4, 5, 6, 7] and [2, 4, 6] on separate lines.

Answer: `['evens'`]

Description: This is an example of using the `Kernnal#loop` method to perform selection over a collection. Selection describes the process of picking certain elements out of a collection based on some condition or expression that evaluates to a Boolean value. In this example all of the even integers found in the array object referenced by local variable `array` are being selected and added to local variable `evens`. The `if array[counter].even?` statment is checking if the element passed to it is even and, if so, should push the current element to the array object referenced by `evens`.

---

```ruby
array = [1, 2, 3, 4, 5, 6, 7]
counter = 0
evens = []

loop do
  break if counter >= array.length
  if array[counter].even?
    evens << ______
  end
  counter += 1
end

p array
p evens
```

Outputs: 1, 2, 3, 4, 5, 6, 7] and [2, 4, 6] on separate lines.

Answer: `['array[counter]']`

Description: This is an example of using the `Kernnal#loop` method to perform selection over a collection. Selection describes the process of picking certain elements out of a collection based on some condition or expression that evaluates to a Boolean value. In this example we are looking for all even integers found in `array`, so when `if array[counter].even?` evaluates to `true`, that means the current element is even and should be pushed to the `evens` array. Therefore `array[counter]` should be placed where the blank space is.

---

```ruby
array = [1, 2, 3, 4, 5, 6, 7]
counter = 0

loop do
  break if counter >= array.length
  array[counter] += ______
  counter += 1
end

p array
```

Outputs: [2, 3, 4, 5, 6, 7, 8]

Answer: `['1']`

Description: This is an example of using the `Kernnal#loop` method to perform transformation over a collection. Transformation describes the process of manipulating each element in the collection, and using some evaluated expression to transform each element. Unless the process is stopped early, it will return the same amount of elements in the original collection. In this example the code outputs the array object referenced by `array` transformed by all of the integer objects incremented by `1`. Therefore the element reassignment (`[]=`) should be passed in `1` to achieve the output this code produces.

---

```ruby
array = [1, 2, 3, 4, 5, 6, 7]
counter = 0

loop do
  break if counter >= array.length
  array[______] += 1
  counter += 1
end

array
```

Outputs: [2, 3, 4, 5, 6, 7, 8]

Answer: `['counter']`

Description: This is an example of using the `Kernnal#loop` method to perform transformation over a collection. Transformation describes the process of manipulating each element in the collection, and using some evaluated expression to transform each element. Unless the process is stopped early, it will return the same amount of elements in the original collection. In this example each integer object in `array` is being incremented by 1 according to the output. Therefore we should be able to see that some element in `array` is being set to its value plus `1`, and because `counter` is set to `0` and incremented by `1` each iteration it's safe to assume that `counter` being passed as where the blank space is will produce the output of this code.

---

```ruby
comparison = 'Z' <=> 'a'

p comparison

# What will this output?
```

Outputs: What will this output?

Answer: `['-1']`

Description: Ruby uses the comparison method `<=>` to evaluate comparisons between elements in a collection. Expressions using `<=>` need to be performed on two object of the same data type. They then return either a `-1`, `0`, or `1` to indicate whether the first object is greater than, less than, or equal to the second object. Strings are compared in ASCIIbetical Order. In this exmaple `'Z'` has a lesser value than `'a'` because uppercase letters come before lowercase letters in the ASCIIbetical order.

---

```ruby
comparison = 'apple' <=> 'ape'

p comparison

# What will this output?
```

Outputs: What will this output?

Answer: `['1']`

Description: Ruby uses the comparison method `<=>` to evaluate comparisons between elements in a collection. Expressions using `<=>` need to be performed on two object of the same data type. They then return either a `-1`, `0`, or `1` to indicate whether the first object is greater than, less than, or equal to the second object. Strings are compared in ASCIIbetical Order. String beginning with a "lesser" letter in the ASCII table will come before those with a "greater" letter in the ASCII table. In the case where all comparable characters are equal, but one string is longer than the other, the longer string will be considered to be "greater". In this example both strings are the same for the first 3 characters, but because the first string is longer than the second string it is considered 'greater' than the second string, and will return `1`.

---

```ruby
comparison = 1 <=> 'a'

p comparison

# What does this output?
```

Outputs: What will this output?

Answer: `['nil']`

Description: Ruby uses the comparison method `<=>` to evaluate comparisons between elements in a collection. Expressions using `<=>` need to be performed on two object of the same data type. They then return either a `-1`, `0`, or `1` to indicate whether the first object is greater than, less than, or equal to the second object. If the two operands are of different data types, they cannot be compared and nil is returned. The value returned by <=> is used by sorting methods to determine the order in which to place the items. Therefore, if <=> returns nil, the program will throw an ArgumentError. In this case `1` is an integer and `'a'` is a string so `nil` will be output.

---

```ruby
comparison = [1, 1, 2] <=> [1, 2, 3]

p comparison

# What does this output?
```

Outputs: What does this output?

Answer: `['-1']`

Description: Ruby uses the comparison method `<=>` to evaluate comparisons between elements in a collection. Expressions using `<=>` need to be performed on two object of the same data type. They then return either a `-1`, `0`, or `1` to indicate whether the first object is greater than, less than, or equal to the second object. Arrays are also compared element by element using `Array#<=>`. Similarly with `String#<=>`, when all the comparable elements in two arrays of different length are equal, the larger array will be considered to be "greater than".

---

```ruby
friends = { "Ashley" => { job: 'designer', birthday: '8/23' },
            "Joe" => { job: 'bartender', birthday: '7/12' },
            "Sue" => { job: 'producer', birthday: '2/22' }}

p friends["Joe"][______][0]

# What's missing in this example?
```

Outputs: b

Answer: `[':job']`

Description: A nested data structure is any kind of collection that contains other collection(s) as one or more of it's elements. Each element of a collection, whether an upper level collection with collections as it's elements, or an inner collection, uses the element reference method standard for that particular data type. To reference specific elements of an inner sub-collection, chain element reference together. In this example `friends`references a nested hash object, when the key `'Joe'` is chained it then references hash object `{ job: 'bartender', birthday: '7/12' }`. We are missing a key but can see the output is `'b'` so of the 2 available key-value pairs available `:job` is the only that points to a string that has an element at index `0` matching our output. Therefore `:job` is the missing element in this situation.

---

```ruby
array = [[1, 2], [3, 4], [5, 6]]

p array[______]

# What does this output?
```

Outputs: [[1, 2], [3, 4]]

Answer: `['0, 2']`

Description: A nested data structure is any kind of collection that contains other collection(s) as one or more of it's elements. Each element of a collection, whether an upper level collection with collections as it's elements, or an inner collection, uses the element reference method standard for that particular data type. To reference specific elements of an inner sub-collection, chain element reference together. In this example `array` is referencing an array object with 3 array object nested within it. If wanting to reference multiple elements of an array you can state the index of the first element followed by the number of elements total to be referenced. In order to have `[[1, 2], [3, 4]]` output in this case, you would need to start at index `0` and return `2` elements; `[0, 2]`.

---

```ruby
array = [[1, 1], [3, 4], [5, 6]]
array[0][1] = 2

p array

# What's missing in this example?
```

Outputs: [[1, 2], [3, 4], [5, 6]]

Answer: `['0']`

Description: You can chain together element reference with element assignment to reassign individual collection elements anywhere within a nested data structure. Be aware that reassigning or updating individual collection elements is a destructive action that permanently modifies the collection. In this example `array[______]` is referencing the first array object in the object referenced by `array`: `[1, 1]` and then assigning an the element at index 1 to integer object `2`. The output of this code shows you that it is the element at index 1 within the first element of `array` has been reassigned, so `0` is the missing item.

---

```ruby
people = [{name: "Anne", color: "purple"}, {name: "Bill", color: "blue"}]

people[0][______] = "Summer"

p people
```

Outputs: [{:name=>"Anne", :color=>"purple", :season=>"Summer"}, {:name=>"Bill", :color=>"blue"}]

Answer: `[':season']`

Description: You can chain together element reference with element assignment to reassign individual collection elements anywhere within a nested data structure. Be aware that reassigning or updating individual collection elements is a destructive action that permanently modifies the collection. Adding a new key-value pair to a hash object is also done using element assignment. In this example we can see from the output that there is another key-value pair added to the hash object at index `0` of the array object referenced by `array`.

---

```ruby
arr_a = %w(ant bat cat)
arr_b = arr_a.dup

p arr_a.object_id == arr_b.object_id

# What does this output?
```

Outputs: What does this output?

Answer: `['false']`

Description: Ruby has ways of creating shallow copies of various Ruby objects. However, a shallow copy only copies the object the method is called on. This means that if the calling object contains other objects (such as in a collection or nested collection), those objects are shared rather than copied. The elements within a copied collection will reference the same object in memory as the original collection, and this is known as a shallow copy. In this example a shallow copy of `arr_a` is created when the `Object#dup` method is called on it and assigned to `arr_b`. This creates an entirely new object with shared references of the object within it. So when `arr_a.object_id` and `arr_b.object_id` are compared it returns `false`.

---

```ruby
arr_a = %w(ant bat cat)
arr_b = arr_a.dup

arr_b[1].upcase!

p arr_a

# What does this output?
```

Outputs: What does this output?

Answer: `['["ant", "BAT", "cat"]']`

Description: Ruby has ways of creating shallow copies of various Ruby objects. However, a shallow copy only copies the object the method is called on. This means that if the calling object contains other objects (such as in a collection or nested collection), those objects are shared rather than copied. The elements within a copied collection will reference the same object in memory as the original collection, and this is known as a shallow copy. In this example, because a shallow copy only creates a copy of the object it is called upon, only a copy of the array object referenced by `arr_a` is created, not the elements within it. Therefore when the `String#upcase!` method is called on the element at index `1` of `arr_b`, which is destrucive, that is the same object at index `1` of `arr_a` as well, which is why `["ant", "BAT", "cat"]` is returned when the object referenced by `arr_a` is output.

---

```ruby
string = 'hello'
string.freeze
______ << ' world'
```

Outputs: FrozenError: cannot modify frozen string

Answer: `['string']`

Description: Ruby objects can be frozen to prevent them from being modified. To do so, we use the `Object#freeze` method. In this example the object referenced by local variable `string` is frozen, so when the code attempts to concatenate the string object `' world'` onto the `string`, a `FrozenError` is thrown because the object referenced by `string` cannot be modified.

---

```ruby
array = ["apple", "book", "car", "dog"]
array.______

array[0] = 'ant'
```

Outputs: FrozenError (can't modify frozen Array: ["apple", "book", "car", "dog"])

Answer: `['freeze']`

Description: Description: Ruby objects can be frozen to prevent them from being modified. To do so, we use the `Object#freeze` method. In this example a `FrozenError` is thrown which will not allow the object at index `0` of the array object `array` to be reassigned. Therefore we know `array` has been frozen, and the missing element in the code is the `Object#freeze` method.

---

```ruby
nums = [3, 2, 6, 4, 8, 1, 5, 9, 0]

nums.sort { |a, b| ______ }
```

Outputs: [9, 8, 6, 5, 4, 3, 2, 1, 0]

Answer: `["b <=> a"]`

Description: sort returns an array containing all the items in the calling collection sorted. Calling sort with a block gives a way to control how the items are sorted. The block takes two arguments, the two items to be compared, and the return value of the block must be `-1`, `1`, or `0` (i.e. it should probably use `<=>`). You can put additional code in the block if you need to, as long as its return value is one of those supported by `<=>`. In this example the output is the `nums` array sorting in descending order, therefore block parameter `b` will need to be on the left side of the `<=>` operator, and block parameter `a` on the right.

---

```ruby
p (
  ['cat', 'a', 'big', 'always', 'naps'].sort do |a, b|
    ______ <=> b.size
  end
)
```

Outputs: ["a", "cat", "big", "naps", "always"]

Answer: `["a.size"]`

Description: sort returns an array containing all the items in the calling collection sorted. Calling sort with a block gives a way to control how the items are sorted. The block takes two arguments, the two items to be compared, and the return value of the block must be `-1`, `1`, or `0` (i.e. it should probably use `<=>`). You can put additional code in the block if you need to, as long as its return value is one of those supported by `<=>`. In this example a block is passed to the `sort` method and the length of the strings are being compared and sorted. Therefore `a.size` is needed to complete the comparison.

---

```ruby
p (
  [123, 432, 543, 642, 543, 256].______ do |num|
    num.digits.last
  end
)
```

Outputs: [123, 256, 432, 543, 543, 642]

Answer: `['sort_by']`

Description: The `Enumeral#sort_by` method is useful for sorting items via a specific criteria, or sorting items in a hash. It takes a block, and each element in the calling collection is assigned to (one of) the block parameter(s). Then, it uses the return value of the block to determine how the collection should be sorted. `Enumerable#sort_by` always returns an array.Unlike sort, the block does not need to return `-1`, `1`, `0` or `nil`, only the criteria by which you want the collection to be sorted. In this circumstance we know the block is searching for the last digit of the numbers passed into it and sorting accordingly. But because the block is not returning `-1`, `0`, `1` or `nil` we know the `sort` method is not being used, therefore `sort_by` is the what is being used.

---

```ruby
words = ['falafel', 'ape', 'coffee', 'sky', 'pals', 'hi']

shortest_words = words.______(2) { |a, b| a.size <=> b.size }

p shortest_words
```

Outputs: ["hi", "sky"]

Answer: `['min']`

Description: `Enumerable#min` returns the object in the calling collection with the "minimum" value. You can pass it a block to determine how elements are compared. The block takes two arguments (items being compared) and must return either `-1`, `1`, or `0`. You can also pass it an argument `n` in order to return `n` number minimum elements from the calling collection. This subgroup will be returned as a sorted array. The argument can be used both with and without the block. In this example `["hi", "sky"]` is the output and the block is utilizing the `<=>` method, but with the optional argument of `2` being passed to the missing method. This shows that the method is sorting through the array by string length using the operator mehtod and then returning the `2` shortest strings. This is only achievable using the `Enumerable#min` method.

---

```ruby
words = %w(cantaloupe apple durian)

least_vowels = words.min_by(2) { |word| word.count("aeiou") }

p least_vowels
```

Outputs: ["apple", "durian"]

Answer: `['min_by']`

Description: `Enumerable#min_by` is passed a block when invoked, and returns the element from the calling collection for which the block returns the minimum value. Like `Enumerable#min` you can also pass it an argument, `n`, in order to return `n` number of minimum elements as an array sorted by the value given by the block. In this example the block is not utilizing the comparison method but instead looking for a numberical value. Then returning the `2` strings with the least vowels. This is achieved by using the `Enumerable#min_by` method.

---

```ruby
words = %w(cantaloupe apple durian bananas)

p words.______(2)
```

Outputs: ["durian", "cantaloupe"]

Answer: `['max']`

Description: `Enumerable#max` returns the object in the collection with the maximum value. By default, the method uses `<=>` to compare elements within the calling collection. Alternatively, you can pass it a block to determine how elements are compared. The block takes two arguments (the items being compared) and must return either `-1`, `1`, or `0`. The method also takes optional argument `n`, either with or without the block, which causes the method to return `n` number maximum elements in a sorted array. In this example the `<=>` method is being utilized under the hood to compare the string objects based on their ASCII values, starting at the first character. It outputs `2` elements due to the argument passed in and those elements are the elements with the highest ASCII score. The first letters of each string are compared and the highest of the 4 letters are `'d'` and then `'c'`. Hence the output we get dignifies we're using the `Enumerale#max` method.

---

```ruby
words = %w(cantaloupe apple durian)

most_vowels = words.max_by { |word| word.count("aeiou") }

p most_vowels
```

Outputs: "cantaloupe"

Answer: `['max_by']`

Description: `Enumerable#max_by` is passed a block when invoked, and returns the element from the calling collection for which the block returns the maximum value. It also takes an optional argument, `n`, which when given causes the method to return `n` number of maximum elements in an array sorted by the return value of the block. In this example the block is not utilizing the `<=>` method and instead sorting things using a different numberical value. Searching each string object for the instances of a vowel within it, then returning the string with the most vowels. This shows that the method being utilized here is the `Enumerable#max_by` method.

---

```ruby
words = %w(cantaloupe apple durian bananas)

shortest_longest = words.______ { |a, b| a.size <=> b.size }

p shortest_longest
```

Outputs: ["apple", "cantaloupe"]

Answer: `['minmax']`

Description: `Enumerable#minmax` returns a 2 element array which contains both the minimum and maximum values in the calling collection. By default, the method will evaluate all elements with `<=>`. Alternatively, you can pass it a block to determine how elements should be compared. The block takes two arguments (the items to compare) and should return a value of `-1`, `1`, or `0`. In this example the `<=>` method is being utilized to compare the length of the strings. The output is an array containing the shortest and longest string found within the calling object. Therefore it can bededuced that `Enumerable#minmax` is the method being utilized.

---

```ruby
words = %w(cantaloupe apple durian bananas)

p words.______ { |word| word.count("a") }
```

Outputs: ["apple", "bananas"]

Answer: `['minmax_by']`

Description: `Enumerable#minmax_by` is passed a block when invoked. It then returns a two element array in which the first element is that for which the block returns the minimum value, and the second element is that for which the block returns the maximum value. In this example the `<=>` operator is not being utilized, instead a numerical value is being compared. Specifically the number of instances of `a` within each string object. The output gives us the string objects with the least and most instances of `a`, therefore it can be deduced that `Enumerable#minmax_by` is the method being utilized here.

---

```ruby
string = "slowly but surely!"

p string ______
```
Outputs:
`surely!`

Answers:
`[[11..-1], [11..17], [11, 7]]`

Description:
Each individual character in a string can be referenced using an integer based index number. The first character in a string is said to be at index 0. Each subsequent character has an index that is increased by 1.

We can use the `String#[]` method to isolate individual elements, of groups of elements.

---
```ruby
animals = [["dog", "cat"], ["whale", "shark"], ["seagull", "robin"]]

p animals ______[3, 4]
```

Outputs: `['gull']`

Answer: `[[2]]`

Description:
Arrays also use an integer based index number to reference each element within the collection. Similarly to strings, we can use the `Array#[]` method to access individual elements or sub-groups of elements.

---
```ruby
colors = {:Rose => "red",   
          :Lily => "purple",   
          :Marigold => "yellow",   
          :Jasmine => "white"}  

flowers = colors.______
p flowers

```
Outputs: `[:Rose, :Lily, :Marigold, :Jasmine]`

Answer: `keys`

Use the `Hash#keys` method to return an array containing all the keys in the calling hash. Use the `Hash#values` method to return an array containing all the values in the calling hash. Each individual key and value, then, can be accessed via it's index within the array.

---
```ruby
hash = { 1 => 'one', 2 => 'two', 3 => 'three'}  

p hash ______
```
Outputs: `'r'`

Answer: `[[3][2]]`

Description:
Hashes are data structures that use key-value pairs to order objects instead of an integer based index. Either the key or the value in a hash can be any type of Ruby object. Each key in a hash must be unique, but values can be duplicated.

We can access a particular value by using it's associated key with `Hash#[]`


---

```ruby
letters = "abcdef"  

p letters.chars.______("-")   
```

Outputs: `"a-b-c-d-e-f"`

Answer: `join`

Description:
`Array#join` returns a string with the elements of the array joined together. You can pass it a delimiter which will be input between each element in the calling array once it is converted to a string.

---

```ruby
fruits = [[:apple, 4], [:banana, 2], [:orange, 3]]  

p fruits.______
```

Outputs: `{:apple=>4, :banana=>2, :orange=>3}`

Answer: `to_h`

Description:
`Array#to_h` is usually invoked by a two-dimensional array in which each sub-array has two elements, and returns a hash in which each sub-array's elements are the collection's key-value pairs. If you need to convert an array of a different data structure to a hash, you can pass this method a block which returns a two-element array, and these elements will form the key-value pairs in the new hash.


---

```ruby
string = "Fix my tupo!"
string ______ = 'y'
puts string       
```

Outputs: `"Fix my typo!"`

Answer: `[[8]]`

Description:
You can change individual element values within a collection by using a setter method (`[]=`), also known as an "element assigner method". Note that this is a destructive action that permanently modifies the collection. To change the value of a specific character within a string, use `String#[]` combined with the assignment operator.


---
```ruby
[1,2,3,4,5].each do |num|
  p "#{num}!"
  e * 3
end

# What will this return?
```
Outputs:
`"1!2!3!4!5!"`

Answers:
`[[1,2,3,4,5]]`

Description:
`each` accomplishes iteration only. Each element in the calling collection is passed into the block on each iteration and assigned to (one of) the block parameter(s). `each` always returns the original collection, and does not utilize the return value of the block. If you need to use that return value, you need to capture it in a variable.

---
```ruby
array = [1,2,3,4,5]

array.map { |num| num * 5 }

# What will this return?
```

Answer:
`[[5,10,15,20,25]]`

Description:
`map` returns a new array of transformed collection elements. Note that it always returns an array, even when the calling collection is a hash. On each iteration through the collection, the current element is passed to the block and assigned to (one of) the block parameter(s). Then, `map` will use the return value of the block for transformation, by placing the return value of the block into a new collection for each element in the calling collection.


---
```ruby
values = [1, 2, 3].map do |num|
  puts num
  num.odd?
end

# What does this return?
```
Outputs:
```ruby
1
2
3
```
Answer:
`[[true, false, true]]`

Description:
`map` returns a new array of transformed collection elements. Note that it always returns an array, even when the calling collection is a hash. On each iteration through the collection, the current element is passed to the block and assigned to (one of) the block parameter(s). Then, `map` will use the return value of the block for transformation, by placing the return value of the block into a new collection for each element in the calling collection.

---
```ruby
ages = [31, 22, 41]
people = ["Bob", "Alice", "Carol"]

people.______.with_index do |name, idx|
  [name, ages[idx]]
end

p people

```
Outputs:
`[["Bob", 31], ["Alice", 22], ["Carol", 41]]`

Answer:
`map!`

Description:
`map!` returns the very same object it was called upon, except mutated. It is a destructive version of the `map` method. On each iteration through the collection, the current element is passed to the block and assigned to the block parameter. Then, `map!` will use the return value of the block to mutate the calling object.

---

```ruby
[1, 2, 3].select do |num|
  num + 1
  puts num
end

# What will this return?
```
Outputs:
```ruby
1
2
3
```

Answer:
`[[]]`

Description:
`select` is a good choice for the process of selection. `select` will return a new collection of all the elements that have returned a truthy value when passed to the block.

In this case, the return value of the block passed to `select` is always `nil`, which is a falsey value in Ruby. Therefore the `select` method returns an empty array.


---

```ruby
array = [2, 3, 4, 1, 8, 9]

p array.select { |num| num. ______ }

```
Outputs `[2, 4, 8]`

Answer: `even?`

Description:
`select` is a good choice for the process of selection. `select` will return a new collection of all the elements that have returned a truthy value when passed to the block.

Note that if there is no way for the block to return a `false` or `nil` value, all the elements in the calling collection will get selected. It's best to use a conditional (which will return nil if it isn't run) or expression that evaluates to some kind of Boolean.

---

```ruby
array = [2, 3, 4, 1, 8, 9]

p array.______ { |num| num.odd? }

```
Outputs `[2, 4, 8]`

Answer: `reject`

Description: `reject` works the same way as `select`, except it will select the values of the calling object
for which the block evaluates to `false`.


---

```ruby
values = [nil, "blue", 22, 10, "red"]

values.______ { |e| e == nil }

```
Returns: `true`

Answer: `any?`

Description:
`any?` is good for determining if any items in a collection meet a certain criteria. It is passed a block when invoked, and will return `true` if the block ever returns a value other than `false` or `nil`. If no block is given, Ruby will has an implicit block { |obj| obj }, that will cause any? to return true if at least one of the objects in the collection are false or nil. A pattern can also be supplied (with no block) as an argument, and the method will return whether or not the pattern matches with any of the elements in the collection.

---
```ruby
strings = %w(a b c d e f g)

strings.______ { |str| str.size == 1 }

```
Returns: `true`

Answer: `all?`

Description:
`all?` is good for determining if all the items in a collection meet a certain criteria. It is passed a block when invoked, and will return true only if the block never returns a `false` or `nil`.

As with `any?` you can call it without a block for the implied { |obj| obj } evaluation or provide it with a pattern argument to match. In either case, the method will return `true` only if all the elements in the calling collection match the given pattern or return a truthy value in the implied block.


---
```ruby
%w(ant bear cat).______ { |word| word.length >= 4 }

```
Returns: `false`

Answer: `all?`

Description:
`all?` is good for determining if all the items in a collection meet a certain criteria. It is passed a block when invoked, and will return true only if the block never returns a `false` or `nil`.

As with `any?` you can call it without a block for the implied { |obj| obj } evaluation or provide it with a pattern argument to match. In either case, the method will return `true` only if all the elements in the calling collection match the given pattern or return a truthy value in the implied block.

---
```ruby
result = []

("a".."d").to_a.each_with_index do |letter, idx|
  result << ______
end

p result
```
Outputs: `[["a", 1], ["b", 2], ["c", 3]]`

Answer: `[[letter, idx + 1]]`

Description:
`each_with_index` is best used when you need to iterate over a collection and also need to track, use, or manipulate either the index number of each element, or the iteration number (index can serve in place of both). It works similarly to `each`, except a block parameter is assigned to the index number of the current element in the calling collection.

When `each_with_index` is called on a hash, the first argument in the block becomes an array representing each key-value pair, and the second argument is the index number.

---
```ruby
p [:foo, :bar, :jazz].each_with_object(______) do |item, hash|
  hash[item] = item.to_s.upcase
end

```
Outputs: `{:foo=>"FOO", :bar=>"BAR", :jazz=>"JAZZ"}`

Answers: `[{}, Hash.new]`

Description:
`each_with_object` takes both a block and an arbitrary object as arguments. It iterates over the given block for each element in the calling collection, and returns the object that was initially given as an argument. This can be very useful in converting data structures that aren't inherently structured similarly, giving you a way to manipulate two collections at once.

---
```ruby
albums = [["Pink Floyd", "Dark Side of the Moon"],
          ["Michael Jackson", "Thriller"]
          ["Van Halen", "1984"]
          ["Pink Floyd", "The Wall"]
          ["Nirvana", "Nevermind"]

p albums.______([]) do |album, playlist|
  playlist << album if album.include?("Pink Floyd")
end

```
Outputs: `[["Pink Floyd", "Dark Side of the Moon"],["Pink Floyd", "The Wall"]]`

Answers: `[each_with_object, each.with_object]`

Description:
`each_with_object` takes both a block and an arbitrary object as arguments. It iterates over the given block for each element in the calling collection, and returns the object that was initially given as an argument. This can be very useful in converting data structures that aren't inherently structured similarly, giving you a way to manipulate two collections at once.

---
```ruby
range = (0..10)

p range.first ______

```
Outputs: `[0, 1]`

Answer: `(2)`

Description:
`first` can return either the first element in a collection or a group of the first elements in a collection, if the number of elements desired is given as an argument. If the calling collection is empty, the method will return `nil`, unless the optional argument is given in which case it will return an empty array.

`first` always returns these items in the form an array, even if the calling collection is a hash.

---
```ruby
{ a: "ant", b: "bear", c: "cat" }.include?(______)

```
Returns: `true`

Answers: `[:a, :b, :c]`

Description:
Good for determining if a collection contains a particular object as a member, `include?` will return `true` if the object supplied as an argument is considered equal (using `==`) to any elements in the calling collection.

When called on a hash, only checks the values of the key value pairs to see if the argument exists within them. `Hash#include?` is essentially an alias for `Hash#key?` or `Hash#has_key?`

---
```ruby
puts "yay" if [1, 2, 3].all? do |i|
  (1..9).______(i)
end

```
Outputs: `'yay'`

Answers: `include?`

Description:
Good for determining if a collection contains a particular object as a member. `include?` will return `true` if the object supplied as an argument is considered equal (using `==`) to any elements in the calling collection.

When called on a hash, only checks the values of the key value pairs to see if the argument exists within them. `Hash#include?` is essentially an alias for `Hash#key?` or `Hash#has_key?`.

---

```ruby
numbers = (1..25).to_a

p numbers.partition { |n| n.______? }

```
Outputs: `[[1, 3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23, 25], [2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24]]`

Answer: `odd?`

Description:
Useful if you need to split a collection into two sub-groups based on some criteria. `partition` is passed a block and returns two arrays, nested within a larger encompassing array. The first array will contain those elements within the calling collection for whom the block returns a truthy value, and the second array will contain those elements within the calling collection for whom the block returns `false` or `nil`.

---
```ruby
numbers = (1..25).to_a

p numbers.______ { |n| n % 3 == 0 }

```
Outputs: `[[3, 6, 9, 12, 15, 18, 21, 24], [1, 2, 4, 5, 7, 8, 10, 11, 13, 14, 16, 17, 19, 20, 22, 23, 25]]`

Answer: `partition`

Description:
Useful if you need to split a collection into two sub-groups based on some criteria. `partition` is passed a block and returns two arrays, nested within a larger encompassing array. The first array will contain those elements within the calling collection for whom the block returns a truthy value, and the second array will contain those elements within the calling collection for whom the block returns `false` or `nil`.
