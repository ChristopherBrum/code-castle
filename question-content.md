# Quiz Questions for Game

---

```ruby
a = 'string'
a_before_reassignment = a.______
a = 'a different string'
a_after_reassignment = a.______
a_before_reassignment == a_after_reassignment
```

Returns: `true` (last line)

Answers: `['object_id']`

Description: variable reassignment is always non-mutating, because it causes the variable to point to a _new_ object, rather than changing the one it previously referenced.

---

```ruby
def make_uppercase(string)
  string = string.______
  string
end

a = 'defeat monsters'

puts make_uppercase(a)
puts a
```

Outputs: `'DEFEAT MONSTERS'` then `'defeat monsters'`

Answers: `['upcase']`

Description: Copies of objects can be created within a method if we pass objects into methods tht contain reassignment statements. Acting on a reference that has been passed to a method as an argument with a non-mutating method does not mutate the object that was passed as an argument.

---

```ruby
def pluralize(string)
  string ______ 's'
  string
end

a = 'programmer'
b = pluralize(a)

a == b
```

Returns: `false` (last line)

Answers: `['+=', '= string +']`

Description: Assignment operators such as `+=`, `-=`, `*=`, etc can also create a copy of an object passed to a method as an argument. Because they constitute reassignment, these are also considered non- mutating. The code `a == b` returns `false` because `a` references the original string object `'programmer'` while `b` references the string object `'programmers'` which was returned by the `+` method and reassigned to `string` within `pluralize`.

---

```ruby
def emphasize(string)
  string = ______
end

a = 'code with intent'
puts emphasize(a)
puts a
```

Outputs: `'CODE WITH INTENT'` followed by `'CODE WITH INTENT'`

Answers: `['upcase']`

Description: The only time in which reassignment can mutate the original object referenced by the variable is when that same object is returned by the expression to the right of the assignment operator. Mutating methods frequently return `self` (this same object), so in this case the same object is reassigned back to `string`.

---

```ruby
# Methods can mutuate in one of two ways. Either with respect to their ______ or with respect to their ______.
```

Answers: `['arguments', 'caller']`

Description: A method that mutates with respect to its arguments is one that mutates an object that's passed to it when invoked. A method that mutates the caller is one that mutates the calling object itself. The latter is more common than the former. Mutating methods are often demarcated by `!` at the end of their name in Ruby documentation.

---

```ruby
def change_first_element(array)
  ______
  array
end

a = [1, 2, 3, 4]
change_first_element(a)
p a
```

Outputs: `[0, 2, 3, 4]`

Answer: `['array[0] = 0']`

Description: Indexed assignment, when a single element in a collection is reassigned, is mutating even though it looks like a regular assignment statement. This is because the new object created by the reassignment is only on the level of a single element _within_ the collection. The reference to the collection object as a whole remains the same.

---

```ruby
def pluralize(string)
  string << 's'
  string
end

a = 'programmer'
b = pluralize(a)

a == b
```

Returns: `true` (last line)

Answer: `['<<']`

Description: The shovel concatenation operator (`<<`) functions similarly to `+=` with string objects, _except_ that it is a mutating method whereas `+=` is not. Here `a == b` will output `true` because both `a` and `b` will point to the same object in memory.

---

```ruby
def change_object(string)
  ______
end

a = 'change me inside the method'

puts change_object(a)
puts a
```

Output: `'CHANGE ME INSIDE THE METHOD'` then `'CHANGE ME INSIDE THE METHOD'`

Answer: `['string.upcase!']`

Description: A language is said to be _pass by referece_ when a _reference_ to the actual object in memory is passed to a method when we pass methods their arguments. Access to this reference allows methods to permanently change the original objects in memory from within the method's scope. Here we are able to permanently change the original object referenced by `a` by calling a mutating method, `upcase!` on it.

---

```ruby
def change_object(string)
  ______
end

a = 'change me inside the method'

puts change_object(a)
puts a
```

Outputs: `'CHANGE ME INSIDE THE METHOD'` THEN `'change me inside the method'`

Answer: `['string.upcase']`

Description: A _pass by value_ language is one that passes a _copy_ of any given object to the method as an argument instead of a reference to the original object. In a pass by value language, we cannot mutate arguments from within the scope of a method. Ruby is not pass by value, but it can act as if it is, when a copy is generated by a method that is not mutating. Generally, non-mutating methods return some kind of newly created object, which we must capture in a variable so we can utilize them later.

---

```ruby
a = 'hey there!'
a = b
c = 'hey there!'

puts a.___(b)
puts a.___(c)
```

Outputs: `true` followed by `false`

Answer: `equal?`

Description: In Ruby, variables are containers that house references to objects in memory. These objects are assigned to variables using an assignment statement. Once assigned, variables are said to reference the assigned object. If you assign one variable to another, both of those variables will reference the same object in memory. You can use the `.equal?` method to determine if two values are, in fact, the same object in memory. `.equal?` will only return `true` if the actual objects are the same, `false` otherwise, even if the values match, as is the case when we compare `a` and `c` above.

---

```ruby
# Name one kind of immutable object in Ruby
```

Answers: `['integers', 'floats', 'true', 'false', 'nil', 'ranges']`

Description: An immutable object is one that cannot be changed. Ostensibly, this means that no mutating methods are defined for immutable objects. Note that because numerical objects in Ruby are immutable, any arithmetic operations we perform will always return a new value, and never mutate the original.

---

```ruby
a = 'how many of me are there?'
b = 'how many of me are there?'
c = 'how many of me are there?'
d = 'how many of me are there?'

match = a.object_id

same_objects_in_mem = [b, c, d].select { |obj| obj.object_id == match }

p same_objects_in_mem
# => ______
```

Outputs: ???

Answer: `[]`

Description: Just because values are equal does not necessarily mean they are the same object in memory. All four string objects initialized above are different objects in memory. Therefore, only one of them `a` will have an object id that matches that of `a`. Therefore none of the strings will be selected and an empty array will be output.

---

```ruby
colors = ['blue', 'green']
______ = colors
puts a
puts b

a = 'purple'
puts array
```

Outputs: `'blue'` followed by `'green'` followed by `['purple', 'green']`

Answer: `['a, b']`

Description: We can use parallel assignment to assign the elements in an array to different variables. The syntax is `var_1, var_2 = [ele_1, ele_2]`. Be warned, a collection as a whole can be mutated through a variable that references one of its elements. Here, when we reassign `a` and change `'blue'` to `'purple'` we mutate the array `colors`.

---

```ruby
fruits = ['apple', 'banana', 'cantaloupe', 'durian']
fruits.freeze
______
p fruits
```

Output: `['apple!!!', 'banana', 'cantaloupe', 'durian']`

Answer: `['fruits[0] << !!']`

Description: Freezing a collection only works on the higher level of the collection as a whole. Because the individual elements are distinct object references on their own, they are not frozen and can still be mutated. This results in a permanent change to the collection as a whole.

---

```ruby
colors = ['red', 'yellow']
fruits = ['apple', 'banana']
stuff = [colors, fruits]
p stuff

______
p stuff
```

Outputs: `[['red', 'yellow'], ['apple', 'banana']]` followed by `[['red', 'purple'], ['apple', 'banana']]`

Answer: `['fruits[1] = 'purple']`

Description: Nested collections have many levels of variable reference, all of which can be assigned to different variables. Changing anything on a lower level, such as the `fruits[1]` element here which is changed from `'yellow'` to `'purple'` can mutate the collection as a whole.

---

```ruby
def shout(string)
  ______
  ______
  string
end

a = 'why are we shouting'

puts shout(a)
puts a
```

Outputs: `'WHY ARE WE SHOUTING!!!'` followed by `'WHY ARE WE SHOUTING'`

Answers: `['string.upcase!', "string += '!!!'"]`

Description: The link between method argument and the original argument passed in can be broken at any point during the method execution. Here we pass in the string `'why are we shouting'` which gets mutated by the `upcase!` method. However, then we try to apply `'!!!'` with the `+=` reassignment operator, which returns a new value. Therefore, the original string never gets the `'!!!'` concatenated, as shown by the output.

---

```ruby
def redact_information(string)
  ______
end

credit_card = '1234-1234-1234-1234'

puts redact_information(credit_card)
puts credit_card
```

Outputs: `'#1234'` followed by `'#1234'`

Answers: `["string [0...string.length - 4] = '#'"]`

Description: By using all the various ways of individual element reference available to use for collections such as strings and arrays, we can mutate whole sections of these collections through element reassignment. Here we take a long string representing a credit card number and try to the sensitive information better for display. In doing so, however, we permanently modify the original string and lose important data.

---

```ruby
# Name two String methods that mutate the caller and do not contain an ! in their names.
```

Answers: `['clear', 'replace', 'insert', 'concat', 'prepend', '<<', '[]=']`

Description: While it is a convention that most mutating methods will be named with a `!`, there are some that are not. It's good to be aware of them so you don't wind up with unexpected behavior.

---

```ruby
# Name four Array methods that mutate the caller and do not contain an ! in their names.
```

Answers: `['<<', '[]=', 'append', 'clear', 'concat', 'delete', 'delete_at', 'delete_if', 'fill', 'replace', 'insert', 'keep_if', 'pop', 'prepend', 'unshift', 'push', 'shift']`

Description: While it is a convention that most mutating methods will be named with a `!`, there are some that are not. It's good to be aware of them so you don't wind up with unexpected behavior.

---

```ruby
array = ['a', 'b', 'c', 'd']

array.each do |letter|
  _____
end

p array
```

Outputs: `["A", "B", "C", "D"]`

Answers: `['letter.upcase!']

Description: It's also possible to mutate elements within a collection while iterating over it. Be careful that you don't make any permanent changes to your collections while manipulating on the level of a single element.

---

```ruby
i = 0
______ do
  i += 2
  puts i
  break if i >= 10
end
```

Outputs: 2, 4, 6, 8, and 10 on separate lines.

Answer: `['loop']`

Description: This is an example of iteration using the `Kernal#loop` method to iterate through a collection. The blank line is missing the `loop` method invocation. 

---

```ruby
i = 0
loop do
  i += 2
  puts i
  ______ if i >= 10
end
```

Outputs: 2, 4, 6, 8, and 10 on separate lines.

Answer: `['break']`

Description: This is an example of iteration using the `Kernal#loop` method to iterate through a collection. The missing element is a `break` keyword, which will exit the loop when a certain condition is met. 

---

```ruby
array = ['one', 'two', 'three', 'four']
______ = 0

loop do
  puts array[counter]
  counter += 1
  break if counter >= array.length
end
```

Outputs: one, two, three, and four on separate lines. 

Answer: `['counter']`

Description: This is an example of iteration using the `Kernal#loop` method to iterate through a collection. In order to break out of a loop the `break` keyword can be used. When used in conjunction with an `if` conditional statement the condition must evaluate to true in order for the `break` keyword to execute and to exit the loop. In this example the object referenced by local variable `counter` is being asked if it is greater than or equal to the the length of `array`. When this evaluates to `true` then the `break` keyword will break out of the loop. Because of variable scoping rules local variable `counter` must be initialized outside of the block passed to the `Kernal#loop` method so that it can be incremented upon each iteration of the loop. Therefore local variable `counter` should be initialized to integer object `0` on the second line.

---

```ruby
array = ['one', 'two', 'three', 'four']
counter = 0

loop do
  puts array[counter]
  ______ += 1
  break if counter >= array.length
end
```

Outputs: one, two, three, and four on separate lines. 

Answer: `['counter']`

Description: This is an example of iteration using the `Kernal#loop` method to iterate through a collection. In order to break out of a loop the `break` keyword can be used. When used in conjunction with an `if` conditional statement the condition must evaluate to true in order for the `break` keyword to execute and exit the loop. In this example the object referenced by local variable `counter` is being asked if it is greater than or equal to the the length of `array`. When this evaluates to `true` then the `break` keyword will break out of the loop. In order for the `if` conditional to evaluate to `true` the object referenced by `counter` must be incremented, or else the result will be an infinite loop. Therefore, the clank line should be local variable `counter`.

--- 

```ruby
animals = {
  'dogs' => 12,
  'cats' => 19,
  'turtles' => 31
}

animals_to_adopt = animals.keys
counter = 0

loop do
  break if counter >= animals.length
  current_animal = animals_to_adopt[counter]
  current_animals_available = animals[current_animal]
  puts "The shelter has #{current_animals_available} #{current_animal} available to adopt."
  ______ += 1
end
```

Outputs: The shelter has 12 dogs available to adopt, The shelter has 19 cats available to adopt,  The shelter has 31 turtles available to adopt, all on separate lines.

Answer: `['counter']`

Description: This is an example of iteration using the `Kernal#loop` method to iterate through a collection. In order to break out of a loop the `break` keyword can be used. When the `break` keyword if executed based on an `if` conditional statement there needs to be an element that triggers the `if` statement to evaluate to `true`. This can be done in many ways. In this example the `break` keyword is only executed if the `if` conditional statment evaluates that the object referenced by `counter` is greater than or equal to the length of the `animals` hash. Knowing that `counter` is intialized to `0` above the `Kernal#loop` invocation, somewhere in the block passed to the `Kernal#loop` method `counter` needs to be incremented in order to avoid an infinite loop and trigger the `break` keyword execution. The blank space should be `counter` in order for this code to function properly. 

---

```ruby
array = [1, 2, 3, 4, 5, 6, 7]
counter = 0
evens = []

loop do
  break if counter >= array.length
  if array[counter].even?
    ______ << array[counter]
  end
  counter += 1
end

p array 
p evens
```

Outputs: [1, 2, 3, 4, 5, 6, 7] and [2, 4, 6] on separate lines.

Answer: `['evens'`]

Description: This is an example of using the `Kernnal#loop` method to perform selection over a collection. Selection describes the process of picking certain elements out of a collection based on some condition or expression that evaluates to a Boolean value. In this example all of the even integers found in the array object referenced by local variable `array` are being selected and added to local variable `evens`. The `if array[counter].even?` statment is checking if the element passed to it is even and, if so, should push the current element to the array object referenced by `evens`. 

---

```ruby
array = [1, 2, 3, 4, 5, 6, 7]
counter = 0
evens = []

loop do
  break if counter >= array.length
  if array[counter].even?
    evens << ______
  end
  counter += 1
end

p array 
p evens
```

Outputs: 1, 2, 3, 4, 5, 6, 7] and [2, 4, 6] on separate lines.

Answer: `['array[counter]']`

Description: This is an example of using the `Kernnal#loop` method to perform selection over a collection. Selection describes the process of picking certain elements out of a collection based on some condition or expression that evaluates to a Boolean value. In this example we are looking for all even integers found in `array`, so when `if array[counter].even?` evaluates to `true`, that means the current element is even and should be pushed to the `evens` array. Therefore `array[counter]` should be placed where the blank space is. 

---

```ruby
array = [1, 2, 3, 4, 5, 6, 7]
counter = 0

loop do
  break if counter >= array.length
  array[counter] += ______
  counter += 1
end

p array
```

Outputs: [2, 3, 4, 5, 6, 7, 8]

Answer: `['1']`

Description: This is an example of using the `Kernnal#loop` method to perform transformation over a collection. Transformation describes the process of manipulating each element in the collection, and using some evaluated expression to transform each element. Unless the process is stopped early, it will return the same amount of elements in the original collection. In this example the code outputs the array object referenced by `array` transformed by all of the integer objects incremented by `1`. Therefore the element reassignment (`[]=`) should be passed in `1` to achieve the output this code produces. 

---

```ruby
array = [1, 2, 3, 4, 5, 6, 7]
counter = 0

loop do
  break if counter >= array.length
  array[______] += 1
  counter += 1
end

array   # => [2, 3, 4, 5, 6, 7, 8]
```

Outputs: [2, 3, 4, 5, 6, 7, 8]

Answer: `['counter']`

Description: This is an example of using the `Kernnal#loop` method to perform transformation over a collection. Transformation describes the process of manipulating each element in the collection, and using some evaluated expression to transform each element. Unless the process is stopped early, it will return the same amount of elements in the original collection. In this example each integer object in `array` is being incremented by 1 according to the output. Therefore we should be able to see that some element in `array` is being set to its value plus `1`, and because `counter` is set to `0` and incremented by `1` each iteration it's safe to assume that `counter` being passed as where the blank space is will produce the output of this code.

---

```ruby
comparison = 'Z' <=> 'a'

p comparison

# What will this output?
```

Outputs: What will this output?

Answer: `[-1]`

Description: Ruby uses the comparison method `<=>` to evaluate comparisons between elements in a collection. Expressions using `<=>` need to be performed on two object of the same data type. They then return either a `-1`, `0`, or `1` to indicate whether the first object is greater than, less than, or equal to the second object. Strings are compared in ASCIIbetical Order. In this exmaple `'Z'` has a lesser value than `'a'` because uppercase letters come before lowercase letters in the ASCIIbetical order. 

--- 

```ruby
comparison = 'apple' <=> 'ape'

p comparison

# What will this output?
```

Outputs: What will this output?

Answer: `[1]`

Description: Ruby uses the comparison method `<=>` to evaluate comparisons between elements in a collection. Expressions using `<=>` need to be performed on two object of the same data type. They then return either a `-1`, `0`, or `1` to indicate whether the first object is greater than, less than, or equal to the second object. Strings are compared in ASCIIbetical Order. String beginning with a "lesser" letter in the ASCII table will come before those with a "greater" letter in the ASCII table. In the case where all comparable characters are equal, but one string is longer than the other, the longer string will be considered to be "greater". In this example both strings are the same for the first 3 characters, but because the first string is longer than the second string it is considered 'greater' than the second string, and will return `1`.

---

```ruby
comparison = 1 <=> 'a'

p comparison

# What does this output?
```

Outputs: What will this output?

Answer: `['nil']`

Description: Ruby uses the comparison method `<=>` to evaluate comparisons between elements in a collection. Expressions using `<=>` need to be performed on two object of the same data type. They then return either a `-1`, `0`, or `1` to indicate whether the first object is greater than, less than, or equal to the second object. If the two operands are of different data types, they cannot be compared and nil is returned. The value returned by <=> is used by sorting methods to determine the order in which to place the items. Therefore, if <=> returns nil, the program will throw an ArgumentError. In this case `1` is an integer and `'a'` is a string so `nil` will be output.

---

```ruby
comparison = [1, 1, 2] <=> [1, 2, 3]

p comparison

# What does this output?
```

Outputs: What does this output?

Answer: `[-1]`

Description: Ruby uses the comparison method `<=>` to evaluate comparisons between elements in a collection. Expressions using `<=>` need to be performed on two object of the same data type. They then return either a `-1`, `0`, or `1` to indicate whether the first object is greater than, less than, or equal to the second object. Arrays are also compared element by element using `Array#<=>`. Similarly with `String#<=>`, when all the comparable elements in two arrays of different length are equal, the larger array will be considered to be "greater than".

---

```ruby
friends = { "Ashley" => { job: 'designer', birthday: '8/23' }, 
            "Joe" => { job: 'bartender', birthday: '7/12' },
            "Sue" => { job: 'producer', birthday: '2/22' }}

p friends["Joe"][______][0]

# What's missing in this example?
```

Outputs: b

Answer: `[:job]`

Description: A nested data structure is any kind of collection that contains other collection(s) as one or more of it's elements. Each element of a collection, whether an upper level collection with collections as it's elements, or an inner collection, uses the element reference method standard for that particular data type. To reference specific elements of an inner sub-collection, chain element reference together. In this example `friends`references a nested hash object, when the key `'Joe'` is chained it then references hash object `{ job: 'bartender', birthday: '7/12' }`. We are missing a key but can see the output is `'b'` so of the 2 available key-value pairs available `:job` is the only that points to a string that has an element at index `0` matching our output. Therefore `:job` is the missing element in this situation.

---

```ruby
array = [[1, 2], [3, 4], [5, 6]]

p array[______]

# What does this output?
```

Outputs: [[1, 2], [3, 4]]

Answer: `['0, 2']`

Description: A nested data structure is any kind of collection that contains other collection(s) as one or more of it's elements. Each element of a collection, whether an upper level collection with collections as it's elements, or an inner collection, uses the element reference method standard for that particular data type. To reference specific elements of an inner sub-collection, chain element reference together. In this example `array` is referencing an array object with 3 array object nested within it. If wanting to reference multiple elements of an array you can state the index of the first element followed by the number of elements total to be referenced. In order to have `[[1, 2], [3, 4]]` output in this case, you would need to start at index `0` and return `2` elements; `[0, 2]`.

---

```ruby
array = [[1, 1], [3, 4], [5, 6]]
array[0][1] = 2

p array

# What's missing in this example?
```

Outputs: [[1, 2], [3, 4], [5, 6]]

Answer: `['0']`

Description: You can chain together element reference with element assignment to reassign individual collection elements anywhere within a nested data structure. Be aware that reassigning or updating individual collection elements is a destructive action that permanently modifies the collection. In this example `array[______]` is referencing the first array object in the object referenced by `array`: `[1, 1]` and then assigning an the element at index 1 to integer object `2`. The output of this code shows you that it is the element at index 1 within the first element of `array` has been reassigned, so `0` is the missing item.

---
